#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "linkedlist.h"
#include "value.h"
#include "talloc.h"
#include "assert.h"
#include "parser.h"

/*
 * Function to put values on the stack
 * Value *stack: the stack of tokens
 * Value *token: the value box of the item to add
 * returns: the stack with the new value box on top
 */
Value *push(Value *stack, Value *token) {
    stack = cons(token, stack);
    return stack;
}

/*
 * Function to take values off of the stack
 * returns: Value box of item that was at the top of the stack
 */
Value *pop(Value *stack, Value **popped) {
    *popped = stack->c.car;
    stack = stack->c.cdr;
    return stack;
}
/*
 * Function that prints out an error message if
 * a syntax error has occurred and frees all memory
 */
void syntaxError() {
    printf("Syntax error encountered\n");
    texit(1);
}
/*
 * Function that parses the list of tokens generated by tokenizer
 * Value *tokens: the list of tokens
 * returns: a tree of tokens (without parens) of type Value
 */
Value *parse(Value *tokens) {
    Value *stack = makeNull();
    Value *popped = talloc(sizeof(Value));
    int depth = 0;
    Value *current = tokens;
    assert(current != NULL && "Error (parse): null pointer");
    while (current->type != NULL_TYPE) {
        Value *token = car(current);
        if (token->type !=CLOSE_TYPE) {
            if (token->type == OPEN_TYPE) {
                depth++;
            }
            stack = push(stack, token);
        } else {
            depth--;
            if (depth < 0) {
                printf("Too many close parentheses\n");
                syntaxError();
            }
            Value *tempList = makeNull();
            stack = pop(stack, &popped);
            while (popped->type != OPEN_TYPE) {
                tempList = cons(popped, tempList);
                stack = pop(stack, &popped);
            }
//            if (tempList->type == NULL_TYPE) {
//                printf("null in parser\n");
//                Value *tempVal = talloc(sizeof(Value));
//                tempVal->type = NULL_TYPE;
//                tempList = cons(tempVal, tempList);
//            }
//            printf("type of templist is %i\n", tempList->type);
            stack = push(stack, tempList);

        }
        current = cdr(current);
    }
    if (depth != 0) {
        printf("Not enough close parentheses\n");
        syntaxError();
    }
    Value *tree = stack;
    Value *reverseTree = reverse(tree);
    return reverseTree;
}

/*
 * Helper function to print out the subtrees with parentheses in the correct places
 * Value *subtree: a sublist of the tree
 * bool first: tells the program to print a paren in front of the first CONS_TYPE
 */
void printSubTree(Value *subtree) {
    if(subtree->type == NULL_TYPE){
        return;
    } else if (subtree->type == CONS_TYPE) {
        if (car(subtree)->type == CONS_TYPE) {
            printf("(");
        }
        printSubTree(car(subtree));
        printSubTree(cdr(subtree));
        if (car(subtree)->type == CONS_TYPE) {
            printf(")");
        }
    } else {
        switch (subtree->type) {
            case SYMBOL_TYPE:
                printf("%s ", subtree->s);
                break;
            case INT_TYPE:
                printf("%i ", subtree->i);
                break;
            case DOUBLE_TYPE:
                printf("%f ", subtree->d);
                break;
            case BOOL_TYPE:
                if (subtree->i == 1) {
                    printf("#t ");
                } else if (subtree->i == 0) {
                    printf("#f ");
                }
                break;
            case STR_TYPE:
                printf("%s ", subtree->s);
                break;
            case NULL_TYPE:
                printf("null type\n");
                break;
            case VOID_TYPE:
                printf("void type\n");
                break;
            case CLOSURE_TYPE:
                printf("closure\n");
                printSubTree(car(subtree));
                printSubTree(cdr(subtree));
                break;
            default:
                printf("error in printSubTree\n");
        }
    }
}


/*
 * Prints the tree to the screen in a readable fashion.
 * Value *tree: the pointer to the tree
 */
void printTree(Value *tree) {
    while (tree->type != NULL_TYPE) {
        printSubTree(tree->c.car);
        printf("\n");
        tree = tree->c.cdr;
    }
}

